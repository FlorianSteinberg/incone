From mathcomp Require Import ssreflect ssrfun seq ssrnat ssrbool eqtype.
From mf Require Import all_mf classical_mf.
Require Import all_cont classical_count classical_cont PhiN FMop Umach Uuniv.
Require Import axioms Classical ChoiceFacts.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section classical_machines.
  Context (Q Q' A A': Type).
  Notation B := (Q -> A).
  Notation B' := (Q' -> A').
  Local Open Scope name_scope.
  
  Lemma sing_cmpt_elt M F n (phi: B) (Fphi: B') q' a': M \evaluates F -> F \is_singlevalued ->
    Fphi \from F phi -> M phi (n,q') = Some a' -> a' = Fphi q'.
  Proof.
    move => comp sing FphiFphi ev.
    have [ | [Mphi MphiFphi] prop]:= (comp phi _); first by exists Fphi.
    have eq: Mphi = Fphi by rewrite -(sing phi Fphi Mphi); last apply prop.
    move: Mphi eq MphiFphi => _ -> MphiFphi.
    pose Nphi := (fun q a => (q <> q' /\ Fphi q = a) \/ (q' = q /\ a' = a)).
    have [q | Mphi Mphiprop]:= @full_choice _ _ Nphi.
    - by case: (classic (q = q')) => ass; [exists a'; right | exists (Fphi q); left].
    have MphiMphi: (\F_M) phi Mphi => [q | ].
    - by case: (Mphiprop q) => [[_ <-] | [<- <-]]; [ | exists n].
    apply Some_inj; case: (Mphiprop q') => [[ctr] | [_ ->]] //.
    by have <-: Mphi = Fphi by apply/ sing; apply prop.
  Qed.

  Lemma exists_listf (somea: A) (cnt: nat -> Q) (F: B ->> B'): cnt \is_surjective ->
     exists listf, forall phi n, phi \from dom F ->
	listf (map phi (iseg cnt n)) \from dom F /\
	(listf (map phi (iseg cnt n))) \and phi \coincide_on (iseg cnt n).
  Proof.
    move => sur; have [sec min]:= exists_minsec sur.
    pose R := make_mf (fun L psiL =>
      (exists phi, phi \from dom F /\ map phi (iseg cnt (size L)) = L) ->
      (psiL \from dom F /\ map psiL (iseg cnt (size L)) = L)).
    have Rtot: R \is_total.
    move => L.
    case: (classic (exists phi, phi \from dom F /\
       (map phi (iseg cnt (size L)) = L))) => [[psil [fd eq]] | neg]; first by exists psil.
    - by exists (fun _ => somea) => cntr; exfalso; apply neg.
    have [listf listfprp]:= full_choice _ Rtot.
    exists listf => phi n phifd.
    have [ | fd eq]:= listfprp (map phi (iseg cnt n)).
    - by exists phi; split => //; rewrite !size_map !size_iseg.
    move: eq; rewrite size_map size_iseg; split => //; move: fd => _.
    rewrite coin_agre => q lstn.
    have [m [ineq <-]]:= iseg_ex lstn.
    have: nth (phi (cnt 0)) ([seq listf [seq phi i | i <- iseg cnt n] i | i <- iseg cnt n]) (n - m).-1 =
	  nth (phi (cnt 0)) ([seq phi i | i <- iseg cnt n]) (n - m).-1.
      by rewrite eq.
    rewrite !(nth_map (cnt 0));
     try by case: (n) ineq =>// n' ineq; rewrite size_iseg subSn //=; have: n' - m <= n' by rewrite leq_subr.
    rewrite nth_iseg; suff ->: (n - (n - m).-1).-1 = m by trivial.
    case: n eq ineq lstn => //n eq ineq lstn.
    by rewrite !subSn //; [ rewrite subKn | rewrite leq_subr].
  Qed.

  Lemma cldr_spec phi KL: phi \from cylinder Q A KL <-> phi \is_choice_for (L2MF KL).
  Proof. done. Qed.
    
  Lemma exists_dp (F: B ->> B'): FunctionalChoice_on (seq (Q * A)) (option B) -> exists dp,
        dom (pf2MF dp) === dom (domain_projection F) /\ (domain_projection F) \extends pf2MF dp.
  Proof.
    move => choice.
    have /choice [dp prp]: forall KL, exists ophi,
          (KL \from dom (domain_projection F) <-> exists phi, ophi = some phi) /\
          forall phi, ophi = some phi -> (domain_projection F) KL phi.
    - move => KL.
      case: (classic (KL \from dom (domain_projection F))) => [[phi val] | nfd].
      - by exists (some phi); split => [ | phi' [<-]]; first by split; exists phi.
      by exists None; firstorder.
    exists dp.
    split => [KL | KL phi /= val]; last by apply (prp KL).2; case: (dp KL) val => // _ ->.
    rewrite (prp KL).1 /=.
    by split; case => phi eq; [exists phi; case: (dp KL) eq => // _ -> | exists phi; rewrite eq].
  Qed.
End classical_machines.

Section mathcomp.
  Context (Q A: eqType) (Q' A': Type).
  Notation B := (Q -> A).
  Notation B' := (Q' -> A').
  Local Open Scope name_scope.

  Lemma all_ovrt (P: subset B): countable Q -> countable A -> ouvert P.
  Proof.
    case: (classic (exists phi, phi \from P)) => [[sp spP] | nex]; last first.
    - by exists (fun _ => None); split => [phi [] | phi phiP]//; exfalso; apply/nex; exists phi.
    move => /prod_count prd {}/prd/list_count count.
    have choice: FunctionalChoice_on (seq (Q * A)) B.
    - by apply/count_eqT_choice; first exact/count; right; apply/inhabits/nil.
    move: count => /count_enum/(enum_inh nil) [cnt sur].
    have /choice [p prp]: forall KL, exists phi, phi \from P /\
          ((exists psi, psi \from P /\ psi \from cylinder Q A KL) -> phi \from cylinder Q A KL).
    - move => KL.
      case: (classic (exists phi, phi \from P /\ phi \is_choice_for (L2MF KL))) => [ | nex].
      + by move => [phi [phifP icf ]]; exists phi.
      by exists sp.
    exists (Some \o_f p \o_f cnt).
    split => [phi [n /= <-] | phi phifP K]; first by have []:= prp (cnt n).
    exists (p (zip K (map phi K))).
    split; last by have [n /= <-]:= sur (zip K (map phi K)); exists n. 
    apply/coin_sym/coin_L2MF; apply prp; exists phi; split => //.
    exact/coin_L2MF/coin_ref.
  Qed.
  
  Lemma exists_dp_count_eqT (F: B ->> B'):
    Q \is_countable -> A \is_countable -> exists dp,
        dom (pf2MF dp) === dom (domain_projection F) /\ (domain_projection F) \extends pf2MF dp.
  Proof.
    move => count count'.
    apply/exists_dp/count_eqT_choice; first exact/list_count/prod_count.
    by right; apply/inhabits/nil.
  Qed.
  
  Definition discrete_modulus (F: B ->> B') mu :=
    forall phi q' K K', phi \from dom F ->
                        (mu (zip K (map phi K), q') = inl K' ->
                         exists psi, psi \coincides_with phi \on K
                                     /\
                                     exists a', certificate F K' psi q' a')
                        /\
                        (mu (zip K (map phi K), q') = inr K'
                         ->
                         (K \is_sublist_of K' /\ exists a', certificate F K' phi q' a'))
                        /\
                        ((exists a', certificate F K phi q' a') -> exists K', mu (zip K (map phi K), q') = inr K').
  
  Lemma exists_dmod (F: B ->> B'):
    FunctionalChoice_on (seq (Q * A) * Q') (seq Q + seq Q) ->
    FunctionalChoice_on (seq (Q * A)) (option B) ->
    FunctionalChoice_on Q' nat ->
    Q \is_countable ->
    F \is_continuous -> exists mu, discrete_modulus F mu.
  Proof.
    move => choice choice' choice'' /count_enum enum cont.
    case: (classic (exists phi, phi \from dom F)) => [[somephi spfd] | nfd]; last first.
    - by exists (fun _ => inl nil) => phi q' K K' phifd; exfalso; apply/nfd; exists phi.
    have [dp dpprp]:= exists_dp F choice'.
    case: (classic (exists q:Q, True)) => [[someq _] | nex]; last first.
    - exists (fun _ => inr nil) => phi q' K K' [Fphi val].
      split => //; split => // _; last by exists nil.
      split => [q | ]; first by exfalso; apply/nex; exists q.
      exists (Fphi q') => psi coin.
      have [Lf mod]:= cont phi Fphi val.
      apply/mod; elim: (Lf q') => // q.
      by exfalso; apply/nex; exists q.
    move: enum => /(enum_inh someq) [cnt sur].
    suff /choice [mu prp]: forall (KLq': seq (Q * A) * Q'), exists (oK': option (seq Q),
          (forall K', oK' = Some K' -> (KLq'.1 \from dom (domain_projection F)) ->
                      exists psi, psi \from domain_projection F KLq'.1
                                  /\
                                  exists a', certificate F K' psi KLq'.2 a')
          /\
          (oK' = None <-> exists phi a', phi \from pf2MF dp KLq'.1
                                         /\
                                         certificate F (unzip1 KLq'.1) phi KLq'.2 a').
    - exists mu => phi K q' /dom_dp phifd.
      split => [K' eq | ].
      - have [psi [dpr excrt]]:= (prp (zip K (map phi K), q')).1 K' eq (phifd _).
        exists psi; split; last exact/excrt.
        by apply/coin_L2MF; have []:= dpr.
      have := (prp (zip K (map phi K), q')).2.
      rewrite unzip1_zip => [prp' | ]; last by rewrite size_map.
      split => [/prp' [phi' [a' [dpr crt]]] | [a' crt]].
      - exists a' => psi coin; apply/crt/coin_trans/coin/coin_L2MF.
        by have []:= dpprp.2 (zip K (map phi K)) phi' dpr.
      apply (prp (zip K (map phi K), q')); rewrite unzip1_zip; last by rewrite size_map.
      have /dpprp.1 [psi dpr]:= phifd K; exists psi; exists a'; split => // phi' coin.
      by apply/crt/coin_trans/coin/coin_sym/coin_L2MF; have []:= dpprp.2 _ psi dpr.
    move => [KL q'].
    case E: (dp KL) => [phi | ]; last first.
    - exists (Some nil).
      split => [K' [<-] /dpprp.1 [psi /=] | ]; first by rewrite E.
      by split => //; case => phi [a'] [/=]; rewrite E.
    have phifd: phi \from dom F by apply/(dpprp.2 KL phi _).1; rewrite /= E.
    have [sec ms]:= exists_minsec sur.
    have [ | Lf [mod min]]:= (dom_minmod ms F choice'' phi).2.
    - by have /cont_spec prp:= cont; apply/prp.
    have [a' crt]:= mod q'.
    case cl: (check_sublist (iseg cnt (Lf q')) (unzip1 KL)).
    - move: cl => /clP subl.
      exists None; split => //; split => // _.
      exists phi; exists a'; split; first by rewrite /= E.
      exact/crt_cert/cert_exte/crt_cert/crt.
    exists (some (iseg cnt (Lf q'))).
    split => [_ [<-] KLfd | ].
    exists phi; split; first by apply/dpprp.2 => /=; rewrite E.
    exists a'; apply/crt.
    split => //; case => phi' [b'] [/=].    
    rewrite E => eq crt'.
    
  Qed.

  Lemma U_universal (someq: Q) (F: partial_function B B'):
    Q \is_countable -> F \is_continuous -> exists psiF, (U psiF) \evaluates F.
  Proof.
    move => count cont.
    Print Assumptions exists_modmod.
    have := CM2A someq.
    
    move => /count_enum/(enum_inh someq) [cnt sur] cont.
    have [Ff Fprop] := exists_choice (F: _ ->>(Q'eqType -> _)) somephi' full_choice.
    have [sec ms] := exists_minsec sur.
    have [mf mfmod]:= exists_minmod ms (cont: (F: _ ->> (Q'eqType -> _)) \is_continuous).
    have [listf listfprop] := exists_listf somea (F: _ ->> (Q'eqType -> _)) sur.
    exists (C2MA cnt listf mf Ff).
    rewrite mon_eval; last exact/cont_sing; last exact/U_mon.
    move => phi Fphi FphiFphi.
    have phifd: phi \from dom F by exists Fphi.
    apply/(UpsiF_spec phifd) => //; try by move => n; have []:= listfprop phi n phifd.
    - move => q' n ineq.
      have [a' crt]:= mod_minm ms (mfmod phi phifd) q'.
      rewrite [mf phi q'](crt phi) //.
      have -> //:= crt (listf (map phi (iseg cnt n))) _ (mf (listf (map phi (iseg cnt n)))).
      + have [_ coin]:= listfprop phi n phifd.
        by apply/coin_sym/coin_subl/coin/iseg_subl.
      by apply/mfmod; have []:= listfprop phi n phifd.
    exact/coin_ref.
    exact/mfmod.
    by move => psi psifd; have [mod min]:= mfmod psi psifd.
  Qed.
